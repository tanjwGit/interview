- 以下是对[该文章](https://zhuanlan.zhihu.com/p/43789231)的摘要

<br />

### 关键词
- 对称加密
- 非对称加密
- 数字签名
- 数字证书

<br />
<br />

## 为什么需要加密？
  - http 是明文传输, 信息在传输过程中可能被劫持。

## 对称加密？
  - 使用同一个密钥，在两端同数据进行加、解密;
  - 需要保证没有第三方知晓;
  - 但首次通信传输密钥的过程是 明文，会被第三方知晓密钥的内容, 导致密钥形同虚设;


## 非对称加密？
  - 存在两把密钥
    - 公钥
    - 私钥
    - 公钥 加密的 内容，使用 私钥 解密;
    - 私钥 加密的 内容，使用 公钥 解密;

## 非对称加密可行性？
  - 服务器把公钥通过明文传递给浏览器;
    - 公钥就会泄漏;
  - 导致 浏览器向 服务端 发送， 是加密的;
  - 服务端像浏览器 发送，加密形同虚设;
    - 因为第三方持有公钥，可以解密;

## 两组非对称加密是否可行？
  - 过程
    - 服务端拥有公钥 A1, 和私钥A2;
    - 浏览器拥有公钥 B1, 和私钥B2;
    - 浏览器、服务端 分别把公钥 B1、A1 明文 传输给对方;
    - 之后
      - 浏览器发送 使用 A1 加密;
      - 服务端发送 使用 B1 加密;
  - 缺点 与 漏洞？
    - 性能差，因为非加密非常耗时;
    - 仍会被第三方劫持;
      - 第三方 拥有 公钥 C1, 和私钥C2;
      - 分别与浏览器 服务端 交换 公钥;
      - 相当于作为一个中间人; 

## 非对称加密 + 对称加密是否可行？
  - 过程
    - 服务端拥有公钥 A1, 和私钥A2;
    - 浏览器发起请求, 服务端明文传输 公钥 A1;
    - 浏览器随机生成一个 密钥X, 使用公钥 A1 加密传输;
    - 服务端使用 私钥1A2 解密;
    - 此后双方均使用 密钥X 进行加密通信;
  - 漏洞？
    - 仍然会被劫持
      - 中间人 拥有 公钥 C1, 和私钥C2;
      - 中间人劫持 公钥 A1, 将公钥 C1发送给浏览器;

<br />

---

> 所以，保证 浏览器生成的公钥一定是服务端的公钥 才能解决劫持问题。
---

<br />

## 一条 不证自明 的公理
  - 比如数学公理
  - 比如 三体中 由提出的 三条基本公理 而推断出 黑暗森林;
  - 比如 react 团队 提出的三条公理 的前提下 的 diff 算法;
  - 比如 身份证 可以证明 一个人的身份证号;

## 数字证书
  - 数字证书，就是 CA 机构提供的证明;
  - 网站使用 https 需要向 CA机构 申请一个 数字证书
  - 数字证书包含:
    - 证书持有者信息、
      - 比如: 域名;
    - 证书持有者（服务端）公钥信息

## 证书本身的传输过程中，如何防止被篡改？
  - 证书的内容会生成一个 数字签名
    - 数字签名的制作:
      - CA 拥有 非对称加密的 公钥 和 私钥;
      - CA 把证书的明文数据 进行 hash 处理;
      - 将hash 后的值，使用私钥加密，得到数字签名
  - 证书明文 + 数字签名 组成 数字证书，颁发给 服务器;
  - 通信时 服务端 会将证书 发送给 浏览器

  - 浏览器验证证书真伪:
    1. 浏览器得到 证书， 内含 证书明文T + 数字签名S
    2. 使用 CA 机构的 公钥 进行解密，得到 hash 值; (浏览器内置 CA的公钥)
    3. 使用证书中的hash算法，对证书明文T 进行hash处理;
    4. 比较两个 hash 值, 相等 说明证书可信;

  - 中间人能否修改证书？
    - 如果修改明文, 由于没有CA机构的私钥，无法将证书明文的hash值加密;
    - 浏览器 比较 自己生成的hash 值 和 解密出的证书中的hash 会不相等;

  - 中间人能否替换证书？
    - 中间人自己申请一个证书，替换;
    - 证书中包含域名，如果被替换，浏览器就能知道。
  
  - 为什么制作数字签名时需要hash一次？
    - 非对称加密效率差
    - hash 可以得到固定长度的信息，可以加快加解密的速度;
    - 非对称加密可以加密的消息体长度有上限;

## 最终方案 总结
  - 采用 非对称加密 + 对称加密的方案;
  1. 服务端申请证书, 内含服务端 公钥;
  2. 浏览器使用 CA 机构的公钥，得到证书中的 服务器公钥;
  3. 浏览器自身生成一个密钥，使用 公钥 加密;
    - 只有服务端可以拥有 私钥 解密 出 密钥;
  4. 此后同时使用 密钥 进行加密传输;

  - 整个过程就是为了传输 浏览器生成的 密钥，进行对称加密通信;

## 每次进行https请求都 必须在SSL/TLS层  进行握手 传输密钥吗?
  - 服务器会为每个浏览器 维护一个  sessionID, TLS握手阶段传给浏览器;
  - 浏览器 生成 密钥 传给 服务器;
  - 服务器 将 密钥 存在 相应的 sessionID下;
  - 之后每次请求，浏览器只需要携带 sessionID 就可;


## SSL/TLS层 的握手构成？
 - TODO


## charles 原理？
  - charles只是一个中间代理;
  - 服务器而言, charles就是一个客户端;
  - 对客户端而言, charles就是一个服务器;
  - 客户端信任的charles的证书;