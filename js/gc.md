[浅谈V8引擎内存管理与垃圾回收算法](https://juejin.cn/post/7091088855457071135#heading-0)

## V8垃圾回收策略
* 根据对象的存活时间将内存垃圾进行分代，分代垃圾回收算法就是对不同类别的内存垃圾实行不同的回收算法;

V8将内存分为`新生代`和`老生代`两种
* 新生代内存中的对象存活时间较短;
* 老生代内存中代对象存活时间较长或是常驻内存;

新生代内存存放在新生代内存空间（semispace: 塞姆艾斯贝斯）中，老生代内存存放在老生代内存空间中（oldspace)

* 新生代内存采用Scavenge(斯凯雯奇[ˈskævəndʒ])算法
* 老生代内存采用Mark-Sweep(马克 思维普)和Mark-Compact（马克 卡姆派克特[kəmˈpækt]）算法

## Scavenge算法
![v8内存空间](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc3a280fcda446ffaac03c2c2cc13c32~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

Scavenge的具体实现采用的是Cheney(切尼[ˈtʃeɪni]
)算法
具体为:
1. 将新生代内存空间一分为二，一个空间处于使用状态（FromSpace），一个空间处于空闲状态（称为ToSpace）;
2. 在内存开始分配时，首先在FromSpace中进行分配;
3. 垃圾回收机制执行时会检查FromSpace中的存活对象,存活对象会被会被复制到ToSpace,  复制完成后，将FromSpace清空，并翻转FromSpace和ToSpace的角色；
4. 当一个对象多次复制后依然处于存活状态，则认为其是长期存活对象，会将该对象被移动到老生代空间oldSpace中，采用新的算法进行管理;

* Scavenge算法其实就是在两个空间内来回复制存活对象，是典型的空间换时间做法，所以非常适合新生代内存，因为仅复制存活的对象且新生代内存中存活对象是占少数的。

### 存在的问题

* 拷贝后保持正确的引用关系
> 情景：同一个对象，被引用两个变量引用; 
>> 解决：被引用的对象节点拷贝后，生成一个新的 field（非有徳[fild]） 属性，指向新的内存空间地址，同时更新到旧内存对象的forwarding（佛沃丁['fɔːwədɪŋ]）属性上，因此其他变量可以通过fromSpace空间内旧对象的forwarding属性找到在ToSpace中的引用地址。

> 由此，内存对象同时存在于新生代和老生代之后带来了新问题：
* 内存对象跨代（跨空间）后如何标记
> ?
* 每次写操作时维护记录集的额外开销
> ?
* 缓解Scavenge算法内存利用率不高问题
> 新生代内存中存活对象占比是相对较小的，因此可以在分配空间时，ToSpace可以分配的小一些。做法是将ToSpace空间分成S0和S1两部分，S0用作于ToSpace，S1与原FromSpace合并当成FromSpace;
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3aeea537a6842e79018b7b4a586d4c4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

### Scavenge算法中深度/广度优先的区别

* 垃圾回收算法识别内存对象是否是垃圾的机制一般有两种：引用计数和基于可达性分析;

* 基于可达性分析，就是找出所有的根引用（比如全局变量等），遍历所有根引用，递归根引用上的所有引用，凡是被遍历到的都是存活对象并打上标记，此时空间中的其他内存对象都是死对象，由此构建了一个有向图;

考虑到递归的限制问题，递归逻辑一般采用非递归实现，常见的有广度优先和深度优先算法。两者的区别在于
* 深度优先拷贝到ToSpace时改变了内存对象的排列顺序，使得有引用关系的对象距离较近。原因是拷贝完自己之后直接拷贝自己引用的对象，因此相关的对象便在ToSpace中靠的较近
* 广度优先正好相反

所以深度优先的算法更利于业务逻辑命中缓存，但是其实现需要依赖额外的栈辅助实现算法，对内存空间有消耗。广度优先则相反，无法提升缓存命中，但是其实现可以利用指针巧妙的避开空间消耗，算法的执行效率高；

### 新生代内存对象的晋升条件
1. 对象是否经历过Scavenge回收
2. ToSpace的内存使用占比不能超过限制

判断是否经历过Scavenge的GC的逻辑是，每次GC时给存活对象的age属性+1，当再次GC的时候判断
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d6d6b5f2e834b83a0ef533405b362eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

扩展：
老生代内存中，长期存活的对象较多，无法采取Scavenge算法回收的原因在于：
* 存活对象较多导致复制效率低下
* 浪费了一半的内存空间

## 老生代内存对象的回收算法
老生代内存空间的垃圾回收采用的是标记清除（Mark-Sweep）和标记整理（Mark-Compact）结合的方式。

标记清除分为两部分：
* 标记阶段
* 清除阶段（如果是标记整理则是整理阶段）

### 标记阶段
在标记阶段遍历老生代堆内存中的所有内存对象，并对活着的对象做标记，清除阶段只清理未被标记的对象。原因是：老生代内存中非存活对象占少数。
标记清除存在的问题是清理之后，存在了不连续的空间导致无法继续利用，所以对于老生代内存空间的内存清理需要结合标记整理的方案。该方案是在标记过程中将活着的对象往一侧移动，移动完成后再清理界外的所有非存活对象移除;

## 垃圾回收的全暂停
垃圾回收时需要暂停应用执行逻辑，待垃圾回收机制结束后再恢复应用执行逻辑，该行为称为“全暂停”，也就是常说的Stop The World，简称STW。对新生代内存的垃圾回收该行为对应用执行影响不大，但是老生代内存由于存活对象较多，所以老生代内存的垃圾回收造成的全停顿影响非常大;

## STW优化
> ?

## 减少垃圾回收的影响
思路： 提高执行效率就要尽量减少垃圾回收的执行和消耗;
1. 慎把内存当作缓存，小心把对象当作缓存，要合理限制过期时间和无限增长的问题，可以采用lru策略;
2. Node中避免使用内存存储用户会话，否则在内存中存放大量用户会话对象导致老生代内存激增，影响清理性能进而影响应用执行性能和内存溢出。改进方式使用使用redis等;
> 减少常驻内存对象的数量，垃圾回收更高效;  
> 进程之间可以共享缓存;
